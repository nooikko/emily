import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, Repository, SelectQueryBuilder } from 'typeorm';
import { TraceDB } from '../../observability/decorators/trace.decorator';
import { StructuredLoggerService } from '../../observability/services/structured-logger.service';
import type { AutoCreateThreadDto, CreateThreadDto } from '../dto/create-thread.dto';
import type { ThreadQueryDto, ThreadSearchDto } from '../dto/thread-query.dto';
import type { ThreadListResponseDto, ThreadResponseDto, ThreadStatsResponseDto } from '../dto/thread-response.dto';
import type { BulkUpdateThreadsDto, UpdateThreadDto } from '../dto/update-thread.dto';
import { ConversationThread, ThreadPriority, ThreadStatus } from '../entities/conversation-thread.entity';
import { ThreadCategory } from '../entities/thread-category.entity';
import { MessageSender, ThreadMessage } from '../entities/thread-message.entity';

/**
 * ThreadsService handles all thread-related operations
 *
 * This service provides comprehensive thread management functionality including:
 * - CRUD operations for threads
 * - Advanced querying and filtering
 * - Search capabilities
 * - Statistics and analytics
 * - Integration with existing memory systems
 */
@Injectable()
export class ThreadsService {
  private readonly logger = new StructuredLoggerService(ThreadsService.name);

  constructor(
    @InjectRepository(ConversationThread)
    private readonly threadRepository: Repository<ConversationThread>,
    @InjectRepository(ThreadMessage) readonly _messageRepository: Repository<ThreadMessage>,
    @InjectRepository(ThreadCategory)
    private readonly categoryRepository: Repository<ThreadCategory>,
  ) {}

  /**
   * Create a new conversation thread
   */
  @TraceDB({ name: 'threads.create' })
  async createThread(createThreadDto: CreateThreadDto): Promise<ThreadResponseDto> {
    this.logger.logInfo(`Creating new thread: ${createThreadDto.title}`);

    try {
      // Validate category if provided
      if (createThreadDto.categoryId) {
        await this.validateCategory(createThreadDto.categoryId);
      }

      const thread = this.threadRepository.create({
        ...createThreadDto,
        priority: createThreadDto.priority || ThreadPriority.NORMAL,
        tags: createThreadDto.tags || [],
        status: ThreadStatus.ACTIVE,
      });

      const savedThread = await this.threadRepository.save(thread);

      // Update category thread count if applicable
      if (savedThread.categoryId) {
        await this.incrementCategoryCount(savedThread.categoryId);
      }

      this.logger.logInfo(`Thread created successfully: ${savedThread.id}`);

      return this.mapToResponseDto(savedThread);
    } catch (error) {
      this.logger.error('Failed to create thread', {
        title: createThreadDto.title,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Auto-create a thread from the first message content
   * This is used for backward compatibility with existing threadId usage
   */
  @TraceDB({ name: 'threads.auto_create' })
  async autoCreateThread(autoCreateDto: AutoCreateThreadDto, existingThreadId?: string): Promise<ThreadResponseDto> {
    this.logger.logInfo(`Auto-creating thread from message content${existingThreadId ? ` for ${existingThreadId}` : ''}`);

    try {
      // If existingThreadId matches UUID format and thread exists, return existing
      if (existingThreadId && this.isUUID(existingThreadId)) {
        const existingThread = await this.findThreadById(existingThreadId);
        if (existingThread) {
          return existingThread;
        }
      }

      // Generate title from initial content
      const title = this.generateTitleFromContent(autoCreateDto.initialContent);

      // Find default category if none provided
      let categoryId = autoCreateDto.categoryId;
      if (!categoryId) {
        const defaultCategory = await this.findOrCreateDefaultCategory();
        categoryId = defaultCategory?.id;
      }

      const createDto: CreateThreadDto = {
        title,
        categoryId,
        tags: autoCreateDto.tags || [],
        metadata: {
          source: autoCreateDto.source || 'api',
          autoGenerated: true,
        },
      };

      // If existingThreadId is provided and doesn't exist, use it as the ID
      const thread = this.threadRepository.create({
        ...createDto,
        ...(existingThreadId && this.isUUID(existingThreadId) ? { id: existingThreadId } : {}),
        status: ThreadStatus.ACTIVE,
        priority: ThreadPriority.NORMAL,
      });

      const savedThread = await this.threadRepository.save(thread);

      // Update category thread count
      if (savedThread.categoryId) {
        await this.incrementCategoryCount(savedThread.categoryId);
      }

      this.logger.logInfo(`Thread auto-created successfully: ${savedThread.id}`);

      return this.mapToResponseDto(savedThread);
    } catch (error) {
      this.logger.error('Failed to auto-create thread', {
        existingThreadId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Find a thread by ID
   */
  @TraceDB({ name: 'threads.find' })
  async findThreadById(id: string): Promise<ThreadResponseDto | null> {
    if (!this.isUUID(id)) {
      return null;
    }

    try {
      const thread = await this.threadRepository.findOne({
        where: { id },
        relations: [], // Load relations if needed
      });

      return thread ? this.mapToResponseDto(thread) : null;
    } catch (error) {
      this.logger.error('Failed to find thread', {
        threadId: id,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }

  /**
   * Update a thread
   */
  @TraceDB({ name: 'threads.update' })
  async updateThread(id: string, updateDto: UpdateThreadDto): Promise<ThreadResponseDto> {
    this.logger.logInfo(`Updating thread: ${id}`);

    try {
      const thread = await this.threadRepository.findOne({ where: { id } });
      if (!thread) {
        throw new NotFoundException(`Thread with ID ${id} not found`);
      }

      // Validate category if being updated
      if (updateDto.categoryId && updateDto.categoryId !== thread.categoryId) {
        await this.validateCategory(updateDto.categoryId);
      }

      // Handle category changes for counting
      const oldCategoryId = thread.categoryId;
      const newCategoryId = updateDto.categoryId;

      // Update thread properties
      Object.assign(thread, updateDto);

      const updatedThread = await this.threadRepository.save(thread);

      // Update category counts if category changed
      if (oldCategoryId !== newCategoryId) {
        if (oldCategoryId) {
          await this.decrementCategoryCount(oldCategoryId);
        }
        if (newCategoryId) {
          await this.incrementCategoryCount(newCategoryId);
        }
      }

      this.logger.logInfo(`Thread updated successfully: ${updatedThread.id}`);

      return this.mapToResponseDto(updatedThread);
    } catch (error) {
      this.logger.error('Failed to update thread', {
        threadId: id,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Delete a thread (soft delete by default)
   */
  @TraceDB({ name: 'threads.delete' })
  async deleteThread(id: string, hardDelete = false): Promise<void> {
    this.logger.logInfo(`Deleting thread: ${id}${hardDelete ? ' (hard delete)' : ''}`);

    try {
      const thread = await this.threadRepository.findOne({ where: { id } });
      if (!thread) {
        throw new NotFoundException(`Thread with ID ${id} not found`);
      }

      if (hardDelete) {
        // Hard delete - remove from database
        await this.threadRepository.remove(thread);
      } else {
        // Soft delete - mark as deleted
        thread.status = ThreadStatus.DELETED;
        await this.threadRepository.save(thread);
      }

      // Update category count
      if (thread.categoryId) {
        await this.decrementCategoryCount(thread.categoryId);
      }

      this.logger.logInfo(`Thread deleted successfully: ${id}`);
    } catch (error) {
      this.logger.error('Failed to delete thread', {
        threadId: id,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Query threads with advanced filtering and pagination
   */
  @TraceDB({ name: 'threads.query' })
  async queryThreads(queryDto: ThreadQueryDto): Promise<ThreadListResponseDto> {
    this.logger.logInfo(`Querying threads - Page ${queryDto.page || 1}`);

    try {
      const queryBuilder = this.threadRepository.createQueryBuilder('thread');

      // Apply filters
      this.applyThreadFilters(queryBuilder, queryDto);

      // Apply sorting
      this.applyThreadSorting(queryBuilder, queryDto);

      // Get total count for pagination
      const total = await queryBuilder.getCount();

      // Apply pagination
      queryBuilder.skip(((queryDto.page || 1) - 1) * (queryDto.limit || 20)).take(queryDto.limit || 20);

      // Load relations if requested
      if (queryDto.includeCategory) {
        queryBuilder.leftJoinAndSelect('thread.category', 'category');
      }

      const threads = await queryBuilder.getMany();

      const totalPages = Math.ceil(total / (queryDto.limit || 20));
      const hasMore = (queryDto.page || 1) < totalPages;

      return {
        threads: threads.map((thread) => this.mapToResponseDto(thread)),
        total,
        page: queryDto.page || 1,
        limit: queryDto.limit || 20,
        totalPages,
        hasMore,
      };
    } catch (error) {
      this.logger.error('Failed to query threads', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Search threads with text search capabilities
   */
  @TraceDB({ name: 'threads.search' })
  async searchThreads(searchDto: ThreadSearchDto): Promise<ThreadResponseDto[]> {
    if (!searchDto.query) {
      return [];
    }

    this.logger.logInfo(`Searching threads: ${searchDto.query}`);

    try {
      const queryBuilder = this.threadRepository.createQueryBuilder('thread');

      // Build search conditions
      const searchConditions: string[] = [];
      const searchParams: Record<string, unknown> = {};

      if (searchDto.titleOnly !== true) {
        searchConditions.push('thread.title ILIKE :searchQuery');
      }

      if (searchDto.includeTags !== false) {
        searchConditions.push(':searchQuery = ANY(thread.tags)');
      }

      if (searchDto.includeContent !== false) {
        // Search in message content
        queryBuilder.leftJoin('thread.messages', 'message');
        searchConditions.push('message.content ILIKE :searchQuery');
      }

      if (searchConditions.length === 0) {
        searchConditions.push('thread.title ILIKE :searchQuery');
      }

      searchParams.searchQuery = `%${searchDto.query}%`;
      queryBuilder.where(`(${searchConditions.join(' OR ')})`, searchParams);

      // Only include active threads in search by default
      queryBuilder.andWhere('thread.status != :deletedStatus', {
        deletedStatus: ThreadStatus.DELETED,
      });

      // Apply sorting with recency boost if requested
      if (searchDto.boostRecent !== false) {
        queryBuilder.orderBy('thread.lastActivityAt', 'DESC');
        queryBuilder.addOrderBy('thread.createdAt', 'DESC');
      } else {
        queryBuilder.orderBy('thread.title', 'ASC');
      }

      // Apply limit
      queryBuilder.take(searchDto.limit || 50);

      const threads = await queryBuilder.getMany();

      this.logger.logInfo(`Thread search completed - ${threads.length} results`);

      return threads.map((thread) => this.mapToResponseDto(thread));
    } catch (error) {
      this.logger.error('Failed to search threads', {
        query: searchDto.query,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get thread statistics
   */
  @TraceDB({ name: 'threads.stats' })
  async getThreadStatistics(): Promise<ThreadStatsResponseDto> {
    this.logger.logInfo('Getting thread statistics');

    try {
      const queryBuilder = this.threadRepository.createQueryBuilder('thread');

      const [totalThreads, activeThreads, archivedThreads, deletedThreads, totalMessages, totalUnreadMessages] = await Promise.all([
        queryBuilder.getCount(),
        queryBuilder.clone().where('thread.status = :status', { status: ThreadStatus.ACTIVE }).getCount(),
        queryBuilder.clone().where('thread.status = :status', { status: ThreadStatus.ARCHIVED }).getCount(),
        queryBuilder.clone().where('thread.status = :status', { status: ThreadStatus.DELETED }).getCount(),
        queryBuilder
          .select('SUM(thread.messageCount)', 'sum')
          .getRawOne()
          .then((result) => Number(result.sum) || 0),
        queryBuilder
          .select('SUM(thread.unreadCount)', 'sum')
          .getRawOne()
          .then((result) => Number(result.sum) || 0),
      ]);

      // Get statistics by priority
      const priorityStats = await queryBuilder
        .select('thread.priority', 'priority')
        .addSelect('COUNT(*)', 'count')
        .groupBy('thread.priority')
        .getRawMany();

      const byPriority: Record<string, number> = {};
      for (const stat of priorityStats) {
        byPriority[stat.priority] = Number(stat.count);
      }

      // Get statistics by category
      const categoryQuery = this.threadRepository
        .createQueryBuilder('thread')
        .leftJoin('thread_categories', 'category', 'thread.categoryId = category.id')
        .select("COALESCE(category.name, 'Uncategorized')", 'category')
        .addSelect('COUNT(*)', 'count')
        .groupBy('category.name');

      const categoryStats = await categoryQuery.getRawMany();
      const byCategory: Record<string, number> = {};
      for (const stat of categoryStats) {
        byCategory[stat.category] = Number(stat.count);
      }

      // Get top tags
      const tagQuery = this.threadRepository
        .createQueryBuilder('thread')
        .select('unnest(thread.tags)', 'tag')
        .addSelect('COUNT(*)', 'count')
        .groupBy('tag')
        .orderBy('count', 'DESC')
        .limit(10);

      const tagStats = await tagQuery.getRawMany();
      const topTags: Record<string, number> = {};
      for (const stat of tagStats) {
        if (stat.tag) {
          topTags[stat.tag] = Number(stat.count);
        }
      }

      return {
        totalThreads,
        activeThreads,
        archivedThreads,
        deletedThreads,
        totalMessages,
        totalUnreadMessages,
        byPriority,
        byCategory,
        topTags,
      };
    } catch (error) {
      this.logger.error('Failed to get thread statistics', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Bulk update multiple threads
   */
  @TraceDB({ name: 'threads.bulk_update' })
  async bulkUpdateThreads(bulkUpdateDto: BulkUpdateThreadsDto): Promise<ThreadResponseDto[]> {
    this.logger.logInfo(`Bulk updating ${bulkUpdateDto.threadIds.length} threads`);

    try {
      const threads = await this.threadRepository.find({
        where: { id: In(bulkUpdateDto.threadIds) },
      });

      if (threads.length !== bulkUpdateDto.threadIds.length) {
        throw new BadRequestException('One or more thread IDs not found');
      }

      // Apply updates to each thread
      for (const thread of threads) {
        if (bulkUpdateDto.status !== undefined) {
          thread.status = bulkUpdateDto.status;
        }
        if (bulkUpdateDto.priority !== undefined) {
          thread.priority = bulkUpdateDto.priority;
        }
        if (bulkUpdateDto.categoryId !== undefined) {
          thread.categoryId = bulkUpdateDto.categoryId;
        }
        if (bulkUpdateDto.addTags?.length) {
          thread.tags = [...new Set([...thread.tags, ...bulkUpdateDto.addTags])];
        }
        if (bulkUpdateDto.removeTags?.length) {
          thread.tags = thread.tags.filter((tag) => !bulkUpdateDto.removeTags!.includes(tag));
        }
      }

      const updatedThreads = await this.threadRepository.save(threads);

      this.logger.logInfo(`Bulk update completed - ${updatedThreads.length} threads updated`);

      return updatedThreads.map((thread) => this.mapToResponseDto(thread));
    } catch (error) {
      this.logger.error('Failed to bulk update threads', {
        threadIds: bulkUpdateDto.threadIds,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Update thread activity and message count
   * Called when new messages are added to maintain thread metadata
   */
  async updateThreadActivity(threadId: string, messagePreview?: string, sender?: MessageSender): Promise<void> {
    try {
      const thread = await this.threadRepository.findOne({ where: { id: threadId } });
      if (!thread) {
        return; // Thread doesn't exist, skip update
      }

      thread.updateLastActivity(
        messagePreview,
        sender === MessageSender.HUMAN ? 'human' : sender === MessageSender.ASSISTANT ? 'assistant' : 'system',
      );
      thread.incrementMessageCount();

      await this.threadRepository.save(thread);

      this.logger.debug('Thread activity updated', {
        threadId,
        messageCount: thread.messageCount,
      });
    } catch (error) {
      this.logger.error('Failed to update thread activity', {
        threadId,
        error: error instanceof Error ? error.message : String(error),
      });
      // Don't throw - this is a background operation
    }
  }

  // Private helper methods

  private applyThreadFilters(queryBuilder: SelectQueryBuilder<ConversationThread>, queryDto: ThreadQueryDto): void {
    // Status filter
    if (queryDto.status) {
      queryBuilder.andWhere('thread.status = :status', { status: queryDto.status });
    } else {
      // By default, exclude deleted threads
      queryBuilder.andWhere('thread.status != :deletedStatus', { deletedStatus: ThreadStatus.DELETED });
    }

    // Priority filter
    if (queryDto.priority) {
      queryBuilder.andWhere('thread.priority = :priority', { priority: queryDto.priority });
    }

    // Category filter
    if (queryDto.categoryId) {
      queryBuilder.andWhere('thread.categoryId = :categoryId', { categoryId: queryDto.categoryId });
    }

    // Tags filter
    if (queryDto.tags?.length) {
      if (queryDto.tagsMatchAny) {
        queryBuilder.andWhere('thread.tags && :tags', { tags: queryDto.tags });
      } else {
        queryBuilder.andWhere('thread.tags @> :tags', { tags: queryDto.tags });
      }
    }

    // Search filter
    if (queryDto.search) {
      queryBuilder.andWhere('(thread.title ILIKE :search OR thread.summary ILIKE :search OR :search = ANY(thread.tags))', {
        search: `%${queryDto.search}%`,
      });
    }

    // Unread filter
    if (queryDto.hasUnread) {
      queryBuilder.andWhere('thread.unreadCount > 0');
    }

    // Message count filters
    if (queryDto.minMessageCount !== undefined) {
      queryBuilder.andWhere('thread.messageCount >= :minMessageCount', { minMessageCount: queryDto.minMessageCount });
    }
    if (queryDto.maxMessageCount !== undefined) {
      queryBuilder.andWhere('thread.messageCount <= :maxMessageCount', { maxMessageCount: queryDto.maxMessageCount });
    }

    // Date filters
    if (queryDto.createdAfter) {
      queryBuilder.andWhere('thread.createdAt >= :createdAfter', { createdAfter: queryDto.createdAfter });
    }
    if (queryDto.createdBefore) {
      queryBuilder.andWhere('thread.createdAt <= :createdBefore', { createdBefore: queryDto.createdBefore });
    }
    if (queryDto.lastActivityAfter) {
      queryBuilder.andWhere('thread.lastActivityAt >= :lastActivityAfter', { lastActivityAfter: queryDto.lastActivityAfter });
    }
    if (queryDto.lastActivityBefore) {
      queryBuilder.andWhere('thread.lastActivityAt <= :lastActivityBefore', { lastActivityBefore: queryDto.lastActivityBefore });
    }
  }

  private applyThreadSorting(queryBuilder: SelectQueryBuilder<ConversationThread>, queryDto: ThreadQueryDto): void {
    const sortBy = queryDto.sortBy || 'lastActivityAt';
    const sortDirection = queryDto.sortDirection || 'DESC';

    queryBuilder.orderBy(`thread.${sortBy}`, sortDirection.toUpperCase() as 'ASC' | 'DESC');

    // Add secondary sort for consistency
    if (sortBy !== 'createdAt') {
      queryBuilder.addOrderBy('thread.createdAt', 'DESC');
    }
  }

  private async validateCategory(categoryId: string): Promise<void> {
    const category = await this.categoryRepository.findOne({ where: { id: categoryId } });
    if (!category) {
      throw new BadRequestException(`Category with ID ${categoryId} not found`);
    }
    if (!category.isActive) {
      throw new BadRequestException(`Category with ID ${categoryId} is not active`);
    }
  }

  private async incrementCategoryCount(categoryId: string): Promise<void> {
    try {
      await this.categoryRepository.increment({ id: categoryId }, 'threadCount', 1);
    } catch (error) {
      this.logger.warn('Failed to increment category count', { categoryId, error });
    }
  }

  private async decrementCategoryCount(categoryId: string): Promise<void> {
    try {
      await this.categoryRepository.decrement({ id: categoryId }, 'threadCount', 1);
    } catch (error) {
      this.logger.warn('Failed to decrement category count', { categoryId, error });
    }
  }

  private async findOrCreateDefaultCategory(): Promise<ThreadCategory | null> {
    try {
      let defaultCategory = await this.categoryRepository.findOne({
        where: { name: 'General', isSystem: true },
      });

      if (!defaultCategory) {
        // Create default category
        defaultCategory = this.categoryRepository.create({
          name: 'General',
          description: 'General conversations and miscellaneous topics',
          color: '#6B7280',
          icon: 'chat',
          sortOrder: 0,
          isSystem: true,
          isActive: true,
        });
        defaultCategory = await this.categoryRepository.save(defaultCategory);
      }

      return defaultCategory;
    } catch (error) {
      this.logger.warn('Failed to find or create default category', { error });
      return null;
    }
  }

  private generateTitleFromContent(content: string): string {
    // Clean and truncate content
    const cleanContent = content.trim().replace(/\s+/g, ' ');

    if (cleanContent.length <= 50) {
      return cleanContent;
    }

    // Try to extract first sentence
    const firstSentence = cleanContent.split(/[.!?]/)[0];
    if (firstSentence && firstSentence.length <= 50) {
      return firstSentence.trim();
    }

    // Truncate to 47 characters and add ellipsis
    return `${cleanContent.substring(0, 47)}...`;
  }

  private isUUID(str: string): boolean {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(str);
  }

  private mapToResponseDto(thread: ConversationThread): ThreadResponseDto {
    return {
      id: thread.id,
      title: thread.title,
      summary: thread.summary,
      status: thread.status,
      priority: thread.priority,
      categoryId: thread.categoryId,
      tags: thread.tags,
      messageCount: thread.messageCount,
      unreadCount: thread.unreadCount,
      lastActivityAt: thread.lastActivityAt,
      lastMessagePreview: thread.lastMessagePreview,
      lastMessageSender: thread.lastMessageSender,
      metadata: thread.metadata,
      createdAt: thread.createdAt,
      updatedAt: thread.updatedAt,
    };
  }
}
